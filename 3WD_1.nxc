// #define DRIVE_DISTANCE_CALIB 2500
#define DRIVE_MAX_VEL 0.5 // meters per second
#define DRIVE_ACC 1   // meters per second^2
#define DRIVE_DEACC 0 // meters per second^2, although since the calculations are simplified, 0 is most accurate.

// #define TURN_DEGREE_CALIB 550
#define TURN_MAX_RPS 1 // revolutions of the robot (not motors) per second
#define TURN_ACC 1	   // revolutions per second^2 
#define	TURN_DEACC 0   // revolutions per second^2, although since the calculations are simplified, 0 is most accurate

#define SONAR_NEAR 20
#define LIGHT_THRESHOLD 20

#define LEFT 0
#define RIGHT 1

#define LCD_LINE1 56
#define LCD_LINE2 48
#define LCD_LINE3 40
#define LCD_LINE4 32
#define LCD_LINE5 24
#define LCD_LINE6 16
#define LCD_LINE7 8
#define LCD_LINE8 0

mutex motorMutex;


/********************************
	 MATH/PHYSICS FUNCTIONS
********************************/

int velToPower(float vel) {
	int power = vel*(100/DRIVE_MAX_VEL);
	if (power > 100) {
		power = 100;
	} else if (power < -100) {
		power = -100;
	}
	return power;
}

int rpsToPower(float rps) {
	int power = abs(rps)*(100/TURN_MAX_RPS);
	if (power > 100) {
		power = 100;
	}
	return power;
}

unsigned long timeForDrive(unsigned long dist, float vel, float acc, float deacc) {
	float sec = -((4*vel)/(2*(acc+deacc))) + sqrt(((16*vel*vel)/((4*acc*acc)+(8*acc*deacc)+(4*deacc*deacc))) + ((2*dist)/(acc+deacc)));
	unsigned long ms = sec*1000;
	return ms;
}

unsigned long timeForTurn(long degrees, float rps, float acc, float deacc) {
	float revs = abs(degrees)/360;
	float sec = -((4*rps)/(2*(acc+deacc))) + sqrt(((16*rps*rps)/((4*acc*acc)+(8*acc*deacc)+(4*deacc*deacc))) + ((2*revs)/(acc+deacc)));
	unsigned long ms = sec*1000;
	return ms;
}


/********************************
	    SIMPLE MANOUVERS
********************************/

void halt() {
	OnFwd(OUT_ABC, 0);
}

/* 
float vel, meters per second
 */
void drive(float vel) {
	int power = velToPower(vel);
	if (power >= 0) {
		OnRev(OUT_ABC, power);
	} else {
		OnFwd(OUT_ABC, -power);
	}
}

/*
int dir, LEFT or RIGHT (0 or 1)
float rps, positive revolutions per second
 */
void turn(int dir, float rps) {
	int power = rpsToPower(rps);
	if (power <= 0) {
		halt();
		return;
	}
	if (dir == LEFT) {
		/* Left */
		OnFwd(OUT_A, power);
		OnFwd(OUT_B, 0);
		OnRev(OUT_C, power);
	} else {
		/* Right */
		OnRev(OUT_A, power);
		OnFwd(OUT_B, 0);
		OnFwd(OUT_C, power);
	}
}


/********************************
	 HIGH LEVEL MANOUVERS
********************************/

/* 
Drives the specified distance at the specified speed.

unsigned long distance, any positive long
float vel, meters per second
 */
void driveDistance(unsigned long distance, float vel) {
	if (vel == 0) {
		halt();
		return;
	}
	unsigned long dur = timeForDrive(distance, vel, DRIVE_ACC, DRIVE_DEACC);
	drive(vel);
	Wait(dur);
	halt();
}

/* 
Turns the specified number of degrees at the specified speed.

long degrees, any negative or positive int
float rps, revolutions per second
 */
void turnDegrees(long degrees, float rps) {
	if (rps <= 0) {
		halt();
		return;
	}
	unsigned long dur = timeForTurn(degrees, rps, TURN_ACC, TURN_DEACC);
	int dir;
	if (degrees <= 0) {
		dir = LEFT;
	} else {
		dir = RIGHT;
	}
	turn(dir, rps);
	Wait(dur);
	halt();
}


/********************************
			TASKS
********************************/

task threeSixtyNoScope() {
	Acquire(motorMutex);
	turnDegrees(360, 100);
	Release(motorMutex);
}

task listenSonar() {
	while (true) {
		TextOut(0, LCD_LINE1, NumToStr(SensorUS(IN_1)));
		if (SensorUS(IN_1) < SONAR_NEAR){
			TextOut(0, LCD_LINE1, "STOP at " + NumToStr(SensorUS(IN_1)));
			break;
		}
	}
}

task main() {
	// TextOut(0, LCD_LINE2, NumToStr());
	// turnDegrees(-90, 100);
    // driveDistance(40, -100);
    // turnDegrees(180, 100);
    // driveDistance(40, 100);
    SetSensorLowspeed(IN_1);    // Sonar-Sensor
    SetSensorLight(IN_2);       // Light-Sensor
}

task listenLightSensor() {
	Follows(main);
	while (true) {
		TextOut(0, LCD_LINE1, NumToStr(Sensor(IN_2)));
		if (Sensor(IN_2) < LIGHT_THRESHOLD) { 
			break;
		}
	}
}

task forward() {
	Follows(main);
	while (true) {
		Acquire(motorMutex);
		drive(100);
		Release(motorMutex);
	}
}

task searchTurn() {
	// Follows(main);
	while (true) {
		Acquire(motorMutex);
		turnDegrees(125, 100);
		turnDegrees(-180, 100);
		turnDegrees(90, 100);
		Release(motorMutex);
	}
}

task edgePanic() {
	Follows(listenLightSensor);
	Acquire(motorMutex);
	driveDistance(40, -100);
	turnDegrees(120, 100);
	Release(motorMutex);
}
