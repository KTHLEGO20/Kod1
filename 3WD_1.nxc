#define DRIVE_DISTANCE_CALIB 2500
#define TURN_DEGREE_CALIB 550

#define DRIVE_ACC 1
#define DRIVE_DEACC 0

#define TURN_ACC 1
#define	TURN_DEACC 0

#define DRIVE_MAX_M_PER_S 0.5

#define SONAR_NEAR 20
#define LIGHT_THRESHOLD 20

#define LEFT 0
#define RIGHT 1


#define LCD_LINE1 56
#define LCD_LINE2 48
#define LCD_LINE3 40
#define LCD_LINE4 32
#define LCD_LINE5 24
#define LCD_LINE6 16
#define LCD_LINE7 8
#define LCD_LINE8 0

mutex motorMutex;

int velToPower(float velocity) {
	int power = velocity*(100/DRIVE_MAX_M_PER_S);
	if (power > 100) {
		power = 100;
	} else if (power < -100) {
		power = -100;
	}
	return power;
}

void halt() {
	OnFwd(OUT_ABC, 0);
}

/* 
int speed, -100 to 100
 */
void drive(float velocity) {
	int power = velToPower(velocity);
	if (power >= 0) {
		OnRev(OUT_ABC, power);
	} else {
		OnFwd(OUT_ABC, -power);
	}
}

/* 
int dir, LEFT or RIGHT (0 or 1)
int speed, 0 to 100
 */
void turn(int dir, unsigned int power) {
	
	if (power <= 0) {
		halt();
		return;
	}
	if (dir == LEFT) {
		/* Left */
		OnFwd(OUT_A, power);
		OnFwd(OUT_B, 0);
		OnRev(OUT_C, power);
	} else {
		/* Right */
		OnRev(OUT_A, power);
		OnFwd(OUT_B, 0);
		OnFwd(OUT_C, power);
	}
}

float timeForManouver(unsigned long dist, int vel, int acc, int deacc) {

	float t = -((4*vel)/(2*(acc+deacc))) + sqrt(((16*vel*vel)/((4*acc*acc)+(8*acc*deacc)+(4*deacc*deacc))) + ((2*dist)/(acc+deacc)));
	return t;
}

/* 
long distance, any positive long
int speed, -100 to 100
 */
void driveDistance(unsigned long distance, int speed) {
	if (speed == 0) {
		halt();
		return;
	}
	unsigned long dur = DRIVE_DISTANCE_CALIB*distance/abs(speed);
	drive(speed);
	Wait(dur);
	halt();
}

/* 
int degrees, any negative or positive int
int speed, 0 to 100
 */
void turnDegrees(int degrees, unsigned int speed) {
	if (speed <= 0) {
		halt();
		return;
	}
	unsigned long dur = TURN_DEGREE_CALIB*abs(degrees)/speed;
	int dir;
	if (degrees <= 0) {
		dir = LEFT;
	} else {
		dir = RIGHT;
	}
	turn(dir, speed);
	Wait(dur);
	halt();
}

task threeSixtyNoScope() {
	Acquire(motorMutex);
	turnDegrees(360, 100);
	Release(motorMutex);
}



task listenSonar() {
	while (true) {
		TextOut(0, LCD_LINE1, NumToStr(SensorUS(IN_1)));
		if (SensorUS(IN_1) < SONAR_NEAR){
			TextOut(0, LCD_LINE1, "STOP at " + NumToStr(SensorUS(IN_1)));
			break;
		}
	}
}

task main() {
	// TextOut(0, LCD_LINE2, NumToStr());
	// turnDegrees(-90, 100);
    // driveDistance(40, -100);
    // turnDegrees(180, 100);
    // driveDistance(40, 100);
    SetSensorLowspeed(IN_1);    // Sonar-Sensor
    SetSensorLight(IN_2);       // Light-Sensor
}

task listenLightSensor() {
	Follows(main);
	while (true) {
		TextOut(0, LCD_LINE1, NumToStr(Sensor(IN_2)));
		if (Sensor(IN_2) < LIGHT_THRESHOLD) { 
			break;
		}
	}
}

task forward() {
	Follows(main);
	while (true) {
		Acquire(motorMutex);
		drive(100);
		Release(motorMutex);
	}
}

task searchTurn() {
	// Follows(main);
	while (true) {
		Acquire(motorMutex);
		turnDegrees(125, 100);
		turnDegrees(-180, 100);
		turnDegrees(90, 100);
		Release(motorMutex);
	}
}

task edgePanic() {
	Follows(listenLightSensor);
	Acquire(motorMutex);
	driveDistance(40, -100);
	turnDegrees(120, 100);
	Release(motorMutex);
}
